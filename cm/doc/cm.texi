\input texinfo
@ignore

cm.texi - texinfo documentation for cm

Copyright (C) 2009, 2010, 2012, 2013, 2015, 2016, 2018, 2021, 2022 Andreas Enge

This file is part of CM.

CM is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the
Free Software Foundation; either version 3 of the licence, or (at your
option) any later version.

CM is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
for more details.

You should have received a copy of the GNU General Public License along
with CM; see the file COPYING. If not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@end ignore

@setfilename cm.info
@include version.texi
@settitle CM @value{VERSION}
@iftex
@afourpaper
@end iftex

@set MINGMP 4.3.2
@set MINMPFR 3.0.0
@set MINMPC 1.0.0
@set MINMPFRCX 0.6.3
@set MINPARI 2.11.0
@set AUTHORS Andreas Enge @email{andreas.enge@@inria.fr}
@set COPYRIGHTDATES 2009, 2010, 2012, 2013, 2015, 2016, 2018, 2021, 2022
@syncodeindex fn cp
@syncodeindex tp cp

@ifinfo
@format
START-INFO-DIR-ENTRY
* cm: (cm.info).               Complex Multiplication.
END-INFO-DIR-ENTRY
@end format
@end ifinfo

@iftex
@finalout
@end iftex

@copying
@ifinfo
This is the manual for CM, a software collection for complex multiplication,
version @value{VERSION} as of @value{UPDATED-MONTH}.
@end ifinfo

@sp 1

Copyright (C) @value{COPYRIGHTDATES} @value{AUTHORS}

@sp 2

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end copying

@setchapternewpage on
@titlepage

@title CM
@subtitle Complex Multiplication
@subtitle Version @value{VERSION}
@subtitle @value{UPDATED-MONTH}

@author @value{AUTHORS}

@tex
\global\parindent=0pt
\global\parskip=8pt
\global\baselineskip=13pt
@end tex

@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage
@headings double

@ifnothtml
@contents
@end ifnothtml

@ifnottex
@node Top

@top CM

This manual documents how to install and use CM, version @value{VERSION}

@end ifnottex


@node Introduction
@chapter Introduction
@cindex introduction

The CM software implements the construction of ring class fields of
imaginary quadratic number fields and of elliptic curves with complex
multiplication via floating point approximations. It consists of a library
that can be called from within a C program and of executable command
line applications.
For the implemented algorithms, @pxref{Enge09}.

Given an imaginary quadratic discriminant @math{D<0}, the associated
ring class field is generated by the values of
@cindex singular value
modular functions
in special arguments taken from the quadratic field @math{Q(\sqrt D)};
these values are called
@cindex singular value
@dfn{singular values}
or @dfn{class invariants}.
@cindex class invariant
Depending on @math{D}, different modular functions need to be chosen; we call
the suitable ones
@cindex class function
@dfn{class functions}.
CM implements (to a greater or lesser extent) all major class invariants
described in the literature.


@heading Licence
@cindex licence
@cindex copying conditions

CM is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public licence as published by the
Free Software Foundation; either version 3 of the licence, or (at your
option) any later version.

CM is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public licence
for more details.

You should have received a copy of the GNU General Public licence along
with CM; see the file COPYING. If not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.


@node Installation
@chapter Installation
@cindex installation
@cindex documentation


@node Instructions
@section Instructions
@cindex installation

CM relies on a number of external libraries, which need to be installed
before compiling CM: GNU MP (@pxref{Gretal20}, version @value{MINGMP} or higher),
GNU MPFR (@pxref{HaLePeZi20}, version @value{MINMPFR} or higher),
GNU MPC (@pxref{EnGaThZi20}, version @value{MINMPC} or higher),
MPFRCX (@pxref{Enge21}, version @value{MINMPFRCX} or higher) and
PARI/GP (@pxref{Pari}, version @value{MINPARI} or higher,
compiled with GMP as the arithmetic kernel).
Additionally, FLINT (@pxref{Flint}) can be used if it is available,
but it is not mandatory.
Compilation of CM needs a standards compliant C compiler (preferably
GCC).

These are the steps needed to install CM, provided that the required libraries
are installed in standard locations:

@enumerate
@item
@samp{tar xzf cm-@value{VERSION}.tar.gz}

@item
@samp{cd cm-@value{VERSION}}

@item
@samp{./configure}

@item
@samp{make}

This compiles CM.

@item
@samp{make check}

This performs a few tests to check that CM has been built correctly.

If you get error messages, please report them to the author.

@item
@samp{make install}

This copies the executable applications into the directory @file{/usr/local/bin},
the header files into @file{/usr/local/include},
the library files into @file{/usr/local/lib},
the data files into subdirectories of @file{/usr/local/share/cm}
(see @ref{Data})
and the file @file{cm.info} into @file{/usr/local/share/info}.

It is possible to pass the option @samp{--prefix=/my/install/directory}
to the @samp{./configure} step above, so that all files go into
subdirectories of @file{/my/install/directory} instead of @file{/usr/local}.
@end enumerate

If auxiliary libraries are to be found in non-standard locations, these need
to be passed in the @samp{./configure} step above by adding parameters
@itemize
@item
@samp{--with-gmp=<gmp_install_dir>},
@item
@samp{--with-mpfr=<mpfr_install_dir>},
@item
@samp{--with-mpc=<mpc_install_dir>},
@item
@samp{--with-mpfrcx=<mpfrcx_install_dir>}
@item
@samp{--with-pari=<pari_install_dir>}.
and
@item
@samp{--with-flint=<flint_install_dir>}.
@end itemize

If you wish to compile the parallel, MPI version @code{ecpp-mpi} of the
@code{ecpp} binary for elliptic curve primality proofs, you need to pass
the option @samp{--enable-mpi} (and, of course, have an MPI library
installed against which the binary will be compiled and linked).

For an exhaustive list of configuration parameters, execute
@samp{./configure --help}.


@node Documentation
@section Documentation
@cindex documentation

Besides the texinfo documentation obtained by a simple invocation of
@samp{make}, the commands @samp{make dvi}, @samp{make ps},
@samp{make pdf} and @samp{make html}
create the documentation in the corresponding formats.


@node Data
@section Data
@cindex data
@cindex modular polynomial

Some parameterised families of class functions need additional data (namely,
@dfn{modular polynomials}), which depend on the parameter value, to deduce
the equation of an elliptic curve from the class polynomial. A few modular
polynomials are provided and stored in subdirectories of
@file{/usr/local/share/cm} (or of the subdirectory @file{share/cm} of the
installation directory provided with the @samp{--prefix} configuration
option, respectively). More precisely, these bivariate polynomials relate
the class function with the modular function @math{j}; instantiating in
a class invariant makes it possible to compute the @math{j}-invariant of
a corresponding elliptic curve as a root of the modular polynomial.

An infinite amount of data is needed to handle all possible discriminants
with a given family of class functions, and already covering all moderately
sized discriminants would require gigabytes of data. So only a very small
sample of modular polynomials is currently distributed; if you need more,
please write to the author.

More precisely, the subdirectory @file{/usr/local/share/cm/df} contains
all modular polynomials for double @math{\eta}-quotients that are of the
minimally possible degree 2 in @math{j}; the subdirectory
@file{/usr/local/share/cm/af} contains all modular polynomials for Atkin
functions of degree 2 in @math{j}. All these are functions of some level
@math{N}, invariant under the Fricke-Atkin-Lehner involution, for which
the modular curve @math{X_0^+ (N)} is of genus 0. As a consequence, both
roots in @math{j} of the instantiated modular polynomial yield a suitable
CM elliptic curve.
Finally the subdirectory @file{/usr/local/share/cm/mf} contains all modular
polynomials for triple @math{\eta}-quotients of the minimal degree 4 or of
degree 8 in @math{j}.


@node Library
@chapter Library
@cindex library

The code of CM comes first and foremost as a C library making its
functionalities accessible to external applications. The names of all
publicly accessible, non-static functions and types start by @code{cm_}
to create a name space proper to CM.

If you are not interested in programming in library mode, the project
also comes with a few sample applications described in more detail
in @ref{Applications}; all of them are implemented with just a few
library calls, so describing the library first makes it easier to give
the parameter choices for the applications, and enables you to easily
create small modifications.

Public constants, types and functions are defined in the file
@file{cm.h}; the exact composition of the types is not important to
document here, since they are usually initialised by calls to dedicated
functions and then passed to further functions needing them.
In general, the usual trick known from GMP is applied, that is, the
types are one-dimensional arrays of structs, so that the difference
between passing arguments by value or by reference disappears and it
is usually not necessary to use the @code{&} and @code{*} operators for
referencing and dereferencing.
Also in GMP style, parameters modified by functions are usually passed
first.


@node cm_param
@section CM parameters
@cindex parameters

The @code{cm_param_t} type holds the main parameters fixed before computing
the class field of an imaginary-quadratic order. This is first and foremost
the quadratic discriminant @math{D < 0}. For most applications, it will be
enough to consider fundamental discriminants, but this is not a requirement
of the code, so all quadratic discriminants are accepted; if a
non-fundamental discriminant is provided, the corresponding ring class field
is computed. The second main parameter provides the type of class function
used, either a single function or one out of a parameterised family; in the
latter case also these parameter values are stored.

@deftp Type int_cl_t
This signed 64 bit integer type is used for discriminants.
@end deftp

@deftp Type cm_param_t
This type, used for holding the main parameters of a CM setting,
is defined using the GMP trick of a one-dimensional array of a struct.
There should be no need to manipulate its fields directly.
@end deftp

@deftypefun bool cm_param_init (cm_param_t @var{param}, int_cl_t @var{d}, char @var{invariant}, int @var{maxdeg}, int @var{subfield}, bool @var{verbose})
This function initialises the @var{param} object depending on the main
input @var{d}, a negative quadratic discriminant, and @var{invariant},
one of the following constants describing a class function or a
parameterised family of class functions.
Every class function has a
@cindex height factor
@dfn{height factor} associated to it, which indicates by how much
(asymptotically for @math{|D| \to \infty}) the number of digits of the
largest coefficient, or equivalently the precision required for the floating
point approximations, is smaller than for the @math{j}-function; the latter
works for every discriminant, but leads to the largest class polynomials.
On the other hand, alternative class functions work only for a restricted
class of discriminants each.
@itemize
@item @code{CM_INVARIANT_J}:
   The modular function @math{j} with height factor 1 by definition.
@item @code{CM_INVARIANT_GAMMA3}:
   The modular function @math{\sqrt d \, \gamma_3}, where @math{\gamma_3}
   is a square root of @math{j - 1728}. The additional factor of
   @math{\sqrt d} is needed only to make the class polynomial real.
   Its height factor is 2, and it works whenever @math{D} is odd.
@item @code{CM_INVARIANT_GAMMA2}:
   The modular function @math{\gamma_2}, a cube root of @math{j}.
   Its height factor is 3, and it works whenever @math{D} is not
   divisible by 3.
@item @code{CM_INVARIANT_WEBER}:
   One of the Weber functions @math{f}, @math{f_1} or @math{f_2} or its
   powers. This is a finite family of class functions.
   One of them works when @math{D} is divisible by 4, but not 32,
   with a height factor between 6 and 72.
@item @code{CM_INVARIANT_SIMPLEETA}:
   Simple @math{\eta}-quotients of the form
   @math{\eta (z) / \eta (z/N)} for an integer @math{N} and their powers
   (to an exponent that divides 24),
   @pxref{EnMo14}.
   The code implements only prime power levels @math{N} for which
   @math{X_0(N)} is of genus 0 (and the simple @math{\eta}-quotient is a
   hauptmodul), so that a CM elliptic curve may be deduced without the use
   of a modular polynomial; that is,
   @math{N \in \{ 3, 5, 7, 13, 4, 9, 25 \}}.
   The height factor is between 2 and 24.
@item @code{CM_INVARIANT_DOUBLEETA}:
   Double @math{\eta}-quotients of the form
   @math{(\eta (z/p_1) \eta (z/p_2)) / (\eta (z) \eta (z / (p_1 p_2)))}
   for primes @math{p_1} and @math{p_2}, and their powers,
   @pxref{EnSc04} and @ref{EnSc13}.
   The level of the function is essentially @math{N = p_1 p_2}
   (or, to be more precise, a multiple of @math{N} and a divisor of
   @math{24 N}, which depends on the congruences satisfied by the
   @math{p_i} modulo 24 and the exact power used).
   For @math{p_1, p_2 \to \infty}, these class functions approach a
   height factor of 12; the optimal height factor of 37 is reached
   for @math{p_1=2, p_2=73}.
@item @code{CM_INVARIANT_MULTIETA}:
   Multiple @math{\eta}-quotients for @math{k} primes
   @math{p_1}, ..., @math{p_k} of level @math{N = p_1 \cdots p_k};
   this is the quotient of two products of @math{\eta (z/n)}, where
   @math{n} varies over the @math{2^k} divisors of @math{n}, and the
   @math{n} with an odd number of primes appear in the numerator, those
   with an even number of primes in the denominator,
   @pxref{EnSc13}.
   The code is implemented generically, but currently only triple
   @math{\eta}-quotients (with @math{k=3}) are actually used.
@item @code{CM_INVARIANT_ATKIN}:
   Functions for @math{X_0^+(N)} of genus 0 for a prime level
   @math{N \in \{ 47, 59, 71, 131 \}};
   the functions are optimal in the sense that they have a pole of lowest
   degree at the cusp for a given family. The height factor is between
   24 and 36. On the other hand, this finite family of class functions is
   obtained by applying certain Hecke operators to
   @math{\eta (z) \eta (N z)}, and the numerical evaluation of these Hecke
   operators is costly.
@end itemize

For families of class functions, the function selects the admissible
parameter combination yielding the smallest class polynomial. Admissibility
depends mainly on the discriminant (or more precisely, on the splitting
behaviour of the primes dividing the level @math{N} in @math{Q (\sqrt D)}),
but also on the values of the further arguments to the function.

The parameter @var{maxdeg} sets an upper limit on the degree in @math{j}
of the modular polynomial; it has an effect only for infinite families of
class functions, that is, when @var{invariant} is
@code{CM_INVARIANT_DOUBLEETA} or @code{CM_INVARIANT_MULTIETA}.
When set to 0, it is disabled; when set to -1, it is internally set to the
degree for which modular polynomials are distributed, which makes it
possible to derive a CM elliptic curve from the class polynomial.

Double and multiple @math{\eta}-quotients are known to generate strict
subfields of the class field in some cases, @pxref{EnSc13}. Whether this
is admitted depends on the value of @var{subfield}, which can take the
following constants:
@itemize
@item @code{CM_SUBFIELD_NEVER}:
   Do not choose parameters known to generate subfields.
   This may still happen by chance (and break the computation of a
   Galois tower decomposition).
   This should be chosen to obtain a generator of the class field.
@item @code{CM_SUBFIELD_PREFERRED}:
   Whenever possible, compute a subfield of the class field, and if
   several choices are possible, prefer the one with the biggest index.
   This speeds up the computation of elliptic curve primality proofs
   (ECPP), where finding a root of the class polynomial becomes one of
   the bottlenecks for large input.
@item @code{CM_SUBFIELD_OPTIMAL}:
   Compute the field with the smallest class polynomial, regardless of
   its degree. This will often be a subfield, if available, since the
   index of the subfield lowers the size of the class polynomial by a
   quadratic factor, acting on the degree of the polynomial and on the
   size of its coefficients.
   This is intended to yield optimal speed.
@end itemize

If @var{verbose} is set to @code{true}, some information is printed on
screen during execution.

If an admissible parameter combination is found, the function stores it in
@code{param} and returns @code{true}; otherwise it returns @code{false}.

Since the function does not allocate any memory, there is no corresponding
function @code{cm_param_clear}.
@end deftypefun


@node cm_class
@section Computing class polynomials
@cindex class polynomial

@deftp Type cm_class_t
This type is also implemented as a one-dimensional array of a struct, but
there should not be any need to access its fields.
It stores information about the ring class group and, once computed,
the class polynomial or its decomposition as a tower of Galois fields.
@end deftp

The code for computing class polynomials relies on the PARI library, which
needs to be initialised before calling any of its functions. While it would
be possible to hide this initialisation from the user (inside
@code{cm_class_init}, for instance), this would make it more difficult
to mix CM code with code that uses the PARI library for other purposes.
So there are special functions for initialising and clearing the PARI
library.

@deftypefun void cm_pari_init ()
This function must be called before any other function operating on class
polynomials. Essentially it encapsulates a call to @code{pari_init}.
@end deftypefun

@deftypefun void cm_pari_clear ()
This function should be called at the end of working with the CM library.
Essentially it encapsulates a call to @code{pari_close}.
@end deftypefun

@deftypefun void cm_class_init (cm_class_t @var{c}, cm_param_t @var{param}, bool @var{verbose})
This function should be called after @code{cm_pari_init}.
Given a CM parameter @var{param} initialised with a call to
@code{cm_param_init}, it allocates memory and executes some fast
precomputations (such as the class group), the results of which are
stored in @var{c}.

If @var{verbose} is set to @code{true}, some information is printed on
screen during execution.
@end deftypefun

@deftypefun void cm_class_clear (cm_class_t *@var{c})
This is the counterpart to @code{cm_class_init} and should be called once
the class polynomial is not needed any more to free the allocated space.
@end deftypefun

@deftypefun void cm_class_compute (cm_class_t @var{c}, cm_param_t @var{param}, bool @var{classpol}, bool @var{tower}, bool @var{verbose})

Given a previously initialised @code{cm_class_t} object @var{c} and
corresponding parameter object @var{param}, the function computes
the class polynomial and stores it in @var{c}.

More precisely, if @var{classpol} is set to @code{true}, the function
computes the class polynomial in one variable @math{X} defining the class
field; if @var{tower} is set to @code{true}, it computes the same class
field as a tower of relative extensions of prime degree using the
asymptotically fast algorithms of @pxref{EnMo03}.
Otherwise said, it computes a univariate polynomial @math{f_1} in the
variable @math{X_1} defining an absolute extension @math{K_1/Q}
(or @math{K_1/Q (\sqrt D)}, see below), then a bivariate polynomial
@math{f_2} in @math{X_1} and @math{X_2} defining a relative extension
@math{K_2/K_1}, and so on.
For the function to have any effect, at least one of @var{classpol} or
@var{tower} needs to be set to @code{true}, and usually exactly one is
enough.

The class polynomial (or the bivariate polynomials defining a tower of
Galois extensions) are either real, that is, they have coefficients in
@math{Z}; or they are complex, that is, they have coefficients in the ring
of integers of the imaginary-quadratic field @math{Q (\sqrt D)}.
We write the latter using the standard basis as @math{Z + Z \omega},
where @math{D_0} is the fundamental discriminant attached to @math{D}
and @math{\omega = \sqrt {D_0} / 2} if @math{D_0} is even
and @math{\omega = (1 + \sqrt {D_0}) / 2} if @math{D_0} is odd.

If @var{verbose} is set to @code{true}, some information is printed on
screen during execution.
@end deftypefun

@deftypefun void cm_class_print_pari (FILE* @var{file}, cm_class_srcptr @var{c}, char* @var{fun}, char* @var{var})
Print the computed class polynomial or the relative polynomials defining a
number field tower from @var{c} to @var{file} (which may be @code{stdout},
for instance) in a format that can be copy-pasted or loaded into PARI/GP.
The arguments @var{fun} and @var{var} define the function and variable
names used; if set to @code{NULL}, default values are given.

If computed, the class polynomial is printed with @var{fun} (default
@code {f}) as the name of the polynomial in the variable @var{var} (default
@code {x}); if it is complex, then the second basis element @math{\omega}
is abbreviated to @code{o}.

If computed, the class polynomial tower is printed with @var{fun}@math{_i}
as the name of the @math{i}-th polynomial in @var{var}.
@end deftypefun


@node cm_curve
@section Computing CM elliptic curves
@cindex CM curve

After computing a class field by a call to @code{cm_class_compute}
(either through a class polynomial as an absolute extension or as a tower
of relative extensions, or both), it can be used to derive a CM elliptic
curve over a finite field. The CM library implements the computation of
curves over prime fields, and also returns a point of prime order on such
a curve.

@deftypefun void cm_curve_and_point (mpz_t @var{a}, mpz_t @var{b}, mpz_t @var{x}, mpz_t @var{y}, cm_param_t @var{param}, cm_class_t @var{c}, mpz_t @var{p}, mpz_t @var{l}, mpz_t @var{co}, const char* @var{modpoldir}, bool @var{print}, bool @var{verbose})
Let @var{c} contain a computed class polynomial for the CM parameters
@var{param}. Let @var{p}@math{\geq 5} be a prime such that the elliptic
curve with CM by the discriminant @math{D} in @var{param} has
@var{l}@math{\cdot}@var{co} points, where @var{l} is prime and @var{co}
not divisible by @var{l};
otherwise said, there are integers @math{t} and @math{v} such that
@var{p}@math{+1-t=}@var{l}@math{\cdot}@var{co} and
4@var{p}@math{=t^2-v^2 D}.
Then the function returns in @var{a} and @var{b} the parameters of an
elliptic curve @math{E : Y^2 = X^3 + }@var{a}@math{X +}@var{b} over the
finite field @math{F_p} and in @var{x} and @var{y} a point
@math{P=(}@var{x}@math{,}@var{y}@math{)} of order @var{l}.

@var{modpoldir} is the name of the base directory containing subdirectories
with modular polynomials for the different families of class functions;
for a standard installation, this is @code{/usr/local/share/cm}.

If @var{print} is set to true, the computed curve and point coordinates
are output on screen.

If @var{verbose} is set to @code{true}, some additional information is
printed on screen during execution.
@end deftypefun

@deftypefun void cm_curve_crypto_param (mpz_t @var{p}, mpz_t @var{n}, mpz_t @var{l}, mpz_t @var{co}, int_cl_t @var{d}, int @var{fieldsize}, bool @var{verbose})
This function computes field parameters for a CM curve over a finite field
for the discriminant @var{d} that satisfies the following conditions for
use in an elliptic curve cryptosystem; notice that due to their special
nature, CM curves are not recommended for cryptography, and that further
security considerations should be taken into account. As such, the function
is mainly intended to test @code{cm_curve_and_point}. Besides the
discriminant it takes @var{fieldsize} and outputs in @var{p} the
characteristic of a finite prime field with @var{fieldsize} bits such that
there is an elliptic curve over @math{F_p} with
@var{n}@math{=}@var{l}@math{\cdot}@var{co} points such that
@var{l} is a (pseudo-)prime and @var{co}@math{\in \{ 1, 2, 4, 8 \}}
is the minimal cofactor reachable with this discriminant.

If @var{verbose} is set to @code{true}, some information is printed on
screen during execution.
@end deftypefun


@node cm_ecpp
@section Elliptic Curve Primality Proofs (ECPP)
@cindex primality proof
@cindex ECPP

Primality proving with elliptic curves (ECPP) is one of the main
applications of CM elliptic curves over finite fields. The CM library
implements the asymptotically fast version fastECPP of
@ref{FrKlMoWi04} and @ref{Morain07}.

Certificates are computed and printed in a format compatible with
PARI/GP.

@deftypefun void cm_ecpp (mpz_t @var{N}, const char* @var{modpoldir}, const char* @var{filename}, const char* @var{tmpdir}, bool @var{print}, bool @var{trust}, bool @var{check}, int @var{phases}, bool @var{verbose}, bool @var{debug})
Given a prime number @var{N}, the function computes an ECPP certificate
and prints it to screen if @var{print} is set to @code{true}.
If @var{filename} is different from @code{NULL}, the final ECPP
certificate is output to the file in PARI/GP format, and to a file with
additional suffix @code{.primo} in PRIMO format, and the phase 1 and
phase 2 partial results are read from and written to temporary files
with suffices @code{.cert1} and @code{.cert2}, respectively.
The variable @var{phases} is usually set to 0; alternatively, it can be set
to 1, in which case only the first, downrun phase of ECPP is executed;
or it can be set to 2, in which case a (potentially partial) first phase
result is read from a file and only the second, CM phase of ECPP is
executed, resulting in a (potentially partial, not ending with a number
below 2@sup{64}) certificate. Using values different from 0 makes sense
only when @var{filename} is given at the same time.

If @var{check} is set to @code{true}, then the certificate is checked;
the outcome is printed if @var{verbose} is also set to @code{true}.
Notice that partial certificates are invalid by definition, even if their
content is so far correct.

The directory @var{modpoldir}, usually @code{/usr/local/share/cm}, in which
modular polynomials are stored, is required to be passed to
@code{cm_curve_and_point}.

If @var{trust} is set to @code{true}, then the input number is trusted to
be pseudoprime; otherwise a quick primality test is run.

If @var{verbose} is set to @code{true}, some information is printed on
screen during execution.
In particular, if both @var{print} and @var{verbose} are set to
@code{false}, the function has no visible effect.

If additionally to @var{verbose}, @var{debug} is set to @code{true}, more
information, in particular on timing of different steps of the ECPP
algorithm, which is useful only for debugging purposes, is printed on
screen.

The parameter @var{tmpdir}, if not @code{NULL}, indicates a directory where
files can be written and read that are normally recomputed for every
execution, but that contain data which does not actually depend on the
number to be certified. These could theoretically be distributed with
the code; since they can fill tens of gigabytes, this is not practical,
however, and they are computed and written on the first run.
For the MPI code, this directory needs to be accessible from all MPI
processes. If the variable is @code{NULL}, the data is recomputed every
time.
@end deftypefun


@node Applications
@chapter Applications
@cindex applications

CM comes with a few applications: @code{classpol} for computing class
polynomials and @code{cm} for computing a CM elliptic curve that could
be used for cryptography, and @code{ecpp} for performing elliptic curve
primality proofs. The first two compute one class field or CM elliptic
curve and share a certain number of command line arguments; the third
one currently takes no command line arguments. All of them are implemented
with only a few calls to library functions. The following sections present
the functionality of each application and the command line arguments it
takes, and also reproduce the essential part of its code to further
illustrate the library interface.


@node classpol
@section @code{classpol}
@cindex classpol

The @code{classpol} application takes one mandatory argument,
@code{-d} followed by the absolute
value @math{|D|} of the discriminant. It computes and prints on screen
the class polynomial for @math{D} obtained using the @math{j}-invariant.
The additional parameter @code{-v} enables more verbose output for the
different steps of the algorithm.
@verbatim
$ classpol -d 207
f = x^6+42653766018394018375*x^5-5002547112103664005187500*x^4
+1819343755841562591564610147379736328125*x^3
-210672109851582446065248197114115955810546875*x^2
+12041028291910181818274355885092809398864746093750*x
-183426864580818496179793649372867188930511474609375
@end verbatim

Class polynomials for alternative class invariants are selected using the
@code{-i} argument followed by the type of class function; this
is the same as the library constants given in
@ref{cm_param,,CM parameters}, with
the prefix @code{CM_INVARIANT_} left out and transformed to lower case;
so @code{CM_INVARIANT_WEBER} becomes @code{-iweber}, and so on.
@verbatim
$ classpol -d 207 -i doubleeta -v
Discriminant -207, fundamental discriminant -23
Invariant d, parameter 2_73_1_1
Class number 6
...
f = x^6-6*x^5+16*x^4-22*x^3+16*x^2-5*x+1
@end verbatim
The verbose output tells us that -207 is not a fundamental discriminant,
but a multiple of the fundamental discriminant -23, and that the double
@math{\eta}-quotient used is of level 2@math{\cdot}73 raised to the
power 1 (the second 1 is a technical parameter, indicating the maximal
power that might be needed for this level).

After evaluating the command line parameters, the essential part of
the code implementing this functionality takes less than ten lines:
@verbatim
cm_pari_init ();
if (!cm_param_init (param, d, invariant, 0, CM_SUBFIELD_NEVER, verbose))
   exit (1);
cm_class_init (c, param, verbose);
cm_class_compute (c, param, true, false, verbose);
cm_class_print_pari (stdout, c, NULL, NULL, NULL);
cm_class_clear (c);
cm_pari_clear ();
@end verbatim

The call to @code{cm_param_init} initialises the variable @var{param} by
checking whether the invariant is suitable for the given discriminants and
choosing a class function if this is the case (such as the
@math{\eta}-quotient of level 39 in the example above). Assuming that the
goal is to compute a class field, parameter combinations known to lead to a
strict subfield are excluded by the constant @code{CM_SUBFIELD_NEVER}.
The 0 indicates that the degree of modular polynomials may be arbitrarily
high, since they would only be needed to derive CM elliptic curves.

The calls to @code{cm_pari_init} and @code{cm_class_init} and their
respective @code{clear} counterparts reserve and free memory and carry out
relatively fast precomputations.
The main activity is launched through the call to @code{cm_class_compute},
in which the boolean values indicate that an absolute class polynomial is
to be computed and not a tower of relative extensions.
The result is output by a call to @code{cm_class_print_pari}.


@node cm
@section @code{cm}
@cindex cm

The @code{cm} application takes the same command line arguments
@code{-d}, @code{-i} and @code{-v} as @code{classpol},
@xref{classpol}. It computes a CM curve for the discriminant @math{D}
over a prime field of 256 bits such that its cardinality is
``as prime as possible'', that is prime up to possibly a factor of
2, 4 or 8 depending on @math{D}. The @code{-v} parameter is needed
to print the computed parameters on screen.

@verbatim
cm -d 207 -i doubleeta -v
Invariant d, parameter 2_13_2_2
...
p = 115792089237316195398462578067141184801329650642019283009460547375490535224057
n = 4 * 28948022309329048849615644516785296200162271477044351520651896284230459251901
a = 98163214185470497050837006097264380779085406912553098655936731136039029295843
b = 32285125078980297712817393022671977836076850091512599038419136678099671035526
x = 103397644567197135309633378171745128589056056673675319889645656993433387644320
y = 72297811879224681619558031933509678790723605942283336960075126018884088267112
@end verbatim

The curve has equation @math{E : Y^2 = X^3 + a X + b} over the finite prime
field @math{F_p}, and its cardinality @math{n} is 4 times a prime (for a
prime cardinality, the discriminant must satisfy @math{D \equiv 5 \pmod 8}).
The point of prime order @math{n/4} is given by @math{(x,y)}.

Besides the same calls to functions initialising and clearing data, the core
of the implementation is as follows:
@verbatim
if (!cm_param_init (param, d, invariant, -1, CM_SUBFIELD_OPTIMAL, verbose))
   exit (1);
cm_class_compute (c, param, false, true, verbose);
cm_curve_crypto_param (p, n, l, co, d, 256, verbose);
cm_curve_and_point (a, b, x, y, param, c, p, l, co, CM_MODPOLDIR,
   true, verbose);
@end verbatim

Parameter initialisation uses the arguments @code{CM_SUBFIELD_OPTIMAL}
to indicate that the class invariant expected to be computed in the
fastest time should be used, independently of it leading to a subfield
or the full class field; and -1 to limit the search for class invariants
for which modular polynomials are available. (The verbose output shows
that the @math{\eta}-quotient of level 2@math{\cdot}73 is replaced by the
quotient of level 2@math{\cdot}13 raised to the power 2, which is expected
to yield a larger class polynomial, but for which the modular polynomial
is distributed with the code).

The boolean arguments to @code{cm_class_compute} lead to the computation
of the tower decomposition of the class field instead of the full class
polynomial. The call to @code{cm_curve_crypto_param} determines a suitable
256 bit prime and curve cardinality @var{n}, and the call to
@code{cm_curve_and_point} obtains and prints the curve and the coordinates
of a point of prime order @var{l} on the curve.


@node ecpp
@section @code{eccp}
@cindex ecpp

The @code{ecpp} application computes an ECPP certificate for proving the
primality of the number passed with the @code{-n} command line argument.
It is assumed that this number is a suitably tested pseudo-prime; in
particular, if it is smaller than @math{2^{64}} then it is assumed to be
prime, and no certificate is computed.
The number can simply be given in decimal notation, but also by an
arbitrary GP expression.

The argument @code{-p} causes printing of the certificate on screen,
@code{-v} enables printing of progress information, and @code{-g}
enables even more verbose debug output.

@verbatim
$ ecpp -n 'nextprime(10^31)' -p
c = [[10000000000000000000000000000033, -5882759018432034, 12103604, 25,
[3876868516114165308082393519623, 7268598020338906447634857503614]],
[826200196239071096737717, 667597927066, 916, 0,
[376111257001838975439341, 115218092585553575608847]],
[901965279736248361147, 54401389280, 118118316, 0,
[282628664937444390372, 352399418333719760852]]];
@end verbatim

The resulting line defining the certificate can be copy-pasted into a
PARI/GP session and checked using
@verbatim
? primecertisvalid(c)
@end verbatim
with expected result 1.

Alternatively, the argument @code{-c} checks the validity of the computed
certificate; to see the result, the option @code{-v} needs to be enabled.

The argument @code{-f} @var{filename} stores the computed certificate in
a file of the given name in PARI/GP format, and additionally in the file
@var{filename}@code{.primo} in Primo (@pxref{Primo}) format
(for checking it with Primo, one needs to rename the file to
@var{filename}@code{.out}).
Additionally, it enables checkpointing:
During the first phase of ECPP (the downrun step determining cardinalities
of elliptic curves leading to a primality proof), the file
@var{filename}@code{.cert1} is written, during the second ECPP phase of
computing the elliptic curves by complex multiplication, the file
@var{filename}@code{.cert2} is written.
Upon restart, the program picks up these files and continues where it has
been interrupted. After a successful run, these checkpointing files may
be deleted.

Checkpointing is particularly useful with the MPI based parallel version of
the binary, called @code{ecpp-mpi}; this is created and installed alongside
the sequential @code{ecpp} binary when the @code{--enable-mpi} configure
option is given.

Thus in a suitably set up MPI environment,
@verbatim
$ mpirun ecpp-mpi -g -n '10^1000+453' -c -f cert-1000
@end verbatim
computes and checks an ECPP certificate for the first prime with
1001 digits and stores it into the file @code{cert-1000}, while
outputting debug information on screen.

By default, the code carries out a quick (as opposed to thorough)
primality test, which is meant to catch typos and obvious errors.
If the number is trusted to be pseudoprime since this has been tested
independently, the command line switch @code{-t} can be added to drop
this test.

The environment variable @code{CM_ECPP_TMPDIR}, if set in the shell from
which the binary is invoked, indicates a directory, available from all MPI
processes for the parallel version, in which data that is common over
several invocations can be stored. The data is then computed on the first
run and read from disk during subsequent runs. If the environment variable
is not set, the data is recomputed every time.
This concerns files named @code{cm_h.dat} for class numbers and
@code{cm_prim_xxxx.dat} for primorials.

Setting this variable also causes checkpoint files named
@code{cm_factor_xxxxxxxxxxxxxxxx.dat} to be written to this directory;
they are useful when certifying very large numbers, for which the
program execution may be interrupted during the second ECPP phase.
They depend on the number to be certified and can be deleted after
the certificate creation.

It is possible to run only the first, downrun phase or only the second,
CM phase of ECPP using the command line options @code{-1} or @code{-2},
respectively. Both require that a filename be given with the @code{-f}
option. Running only the first phase makes it possible to allocate a
different (usually larger) number of MPI processes to this phase.
Running only the second phase is possible also when the first phase has
been completed only partially, so that the first elliptic curves, which
often take a very long time, can be obtained on fewer cores in parallel
with the ongoing first phase. Notice that in this case a certificate is
written, but that it is considered invalid in particular by the option
@code{-c}. It can be completed by subsequent runs specifying @code{-1},
@code{-2} or none of them.



@node References
@unnumbered References

@itemize

@item
@anchor{Enge09}
[Enge09]
Andreas Enge.
The complexity of class polynomial computation via floating point
approximations.
@emph{Mathematics of Computation} 78 (266), 2009,
pp. 1089--1107

@item
@anchor{Enge21}
[Enge21]
Andreas Enge.
@code{mpfrcx} -- A library for the arithmetic of univariate polynomials over arbitrary
precision real or complex numbers.
INRIA.
Version 0.6.3, 2021,
@url{http://mpfrcx.multiprecision.org/}

@item
@anchor{EnGaThZi20}
[EnGaThZi20]
Andreas Enge, Micka@"el Gastineau, Philippe Th@'eveny and Paul Zimmermann.
@code{mpc} -- A library for multiprecision complex arithmetic with exact rounding.
INRIA.
Version 1.2.1, 2020,
@url{http://mpc.multiprecision.org/}

@item
@anchor{EnMo03}
[EnMo03]
Andreas Enge and Fran@,{c}ois Morain.
Fast decomposition of polynomials with known Galois group.
In Marc Fossorier, Tom H@o{}holdt and Alain Poli (eds.):
@emph{Applied Algebra, Algebraic Algorithms and Error-Correcting Codes
-- AAECC-15}, 2003,
pp. 254--264

@item
@anchor{EnMo14}
[EnMo14]
Andreas Enge and Fran@,{c}ois Morain.
Generalised Weber functions.
@emph{Acta Arithmetica} 164 (4), 2014,
pp. 309--341

@item
@anchor{EnSc04}
[EnSc04]
Andreas Enge and Reinhard Schertz.
Constructing elliptic curves over finite fields using double eta-quotients.
@emph{Journal de Th@'eorie des Nombres de Bordeaux} 16, 2004,
pp. 555--568

@item
@anchor{EnSc13}
[EnSc13]
Andreas Enge and Reinhard Schertz.
Singular values of multiple eta-quotients for ramified primes.
@emph{LMS Journal of Computation and Mathematics} 16, 2013,
pp. 407--418

@item
@anchor{FrKlMoWi04}
[FrKlMoWi04]
J. Franke and T. Kleinjung and F. Morain and T. Wirth.
Proving the Primality of Very Large Numbers with fastECPP.
In Duncan Buell (ed.):
@emph{Algorithmic Number Theory -- ANTS-VI}, 2004,
pp. 194--207

@item
@anchor{Gretal20}
[Gretal20]
Torbj@"orn Granlund et al.
@code{gmp} -- GNU multiprecision library.
Version 6.2.1, 2020,
@url{http://gmplib.org/}

@item
@anchor{HaLePeZi20}
[HaLePeZi20]
Guillaume Hanrot, Vincent Lef@`evre, Patrick P@'elissier, Paul Zimmermann et al.
@code{mpfr} -- A library for multiple-precision floating-point               computations with exact rounding.
Version 4.1.0, 2020,
@url{http://www.mpfr.org/}

@item
@anchor{Morain07}
[Morain07]
Fran@c{c}ois Morain.
Implementing the asymptotically fast version of the
elliptic curve primality proving algorithm.
@emph{Mathematics of Computation} 76 (257), 2007,
pp. 493--505

@item
@anchor{Pari}
[Pari]
The PARI group.
@code{PARI/GP}.
Version 2.13.4, 2022,
@url{https://pari.math.u-bordeaux.fr/}

@item
@anchor{Flint}
[Flint]
William Hart et al.
@code{FLINT}.
Version 2.9.0, 2022,
@url{https://flintlib.org/}

@item
@anchor{Primo}
[Primo]
Marcel Martin.
@code{Primo}.
Version 4.3.3, 2020,
@url{http://www.ellipsa.eu/public/primo/primo.html}

@end itemize

@node Index
@unnumbered Index
@printindex cp

@bye
