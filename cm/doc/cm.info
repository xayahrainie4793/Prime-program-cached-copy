This is cm.info, produced by .texi2any-real version 7.0.3 from cm.texi.

This is the manual for CM, a software collection for complex
multiplication, version 0.4.2 as of May 2023.


   Copyright (C) 2009, 2010, 2012, 2013, 2015, 2016, 2018, 2021, 2022
Andreas Enge <andreas.enge@inria.fr>



   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.

START-INFO-DIR-ENTRY
* cm: (cm.info).               Complex Multiplication.
END-INFO-DIR-ENTRY


File: cm.info,  Node: Top,  Next: Introduction,  Up: (dir)

CM
**

This manual documents how to install and use CM, version 0.4.2

* Menu:

* Introduction::
* Installation::
* Library::
* Applications::
* References::
* Index::


File: cm.info,  Node: Introduction,  Next: Installation,  Prev: Top,  Up: Top

1 Introduction
**************

The CM software implements the construction of ring class fields of
imaginary quadratic number fields and of elliptic curves with complex
multiplication via floating point approximations.  It consists of a
library that can be called from within a C program and of executable
command line applications.  For the implemented algorithms, *note
Enge09::.

   Given an imaginary quadratic discriminant D<0, the associated ring
class field is generated by the values of modular functions in special
arguments taken from the quadratic field Q(\sqrt D); these values are
called “singular values” or “class invariants”.  Depending on D,
different modular functions need to be chosen; we call the suitable ones
“class functions”.  CM implements (to a greater or lesser extent) all
major class invariants described in the literature.

Licence
=======

CM is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public licence as published by the Free
Software Foundation; either version 3 of the licence, or (at your
option) any later version.

   CM is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public licence for
more details.

   You should have received a copy of the GNU General Public licence
along with CM; see the file COPYING. If not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
USA.


File: cm.info,  Node: Installation,  Next: Library,  Prev: Introduction,  Up: Top

2 Installation
**************

* Menu:

* Instructions::
* Documentation::
* Data::


File: cm.info,  Node: Instructions,  Next: Documentation,  Up: Installation

2.1 Instructions
================

CM relies on a number of external libraries, which need to be installed
before compiling CM: GNU MP (*note Gretal20::, version 4.3.2 or higher),
GNU MPFR (*note HaLePeZi20::, version 3.0.0 or higher), GNU MPC (*note
EnGaThZi20::, version 1.0.0 or higher), MPFRCX (*note Enge21::, version
0.6.3 or higher) and PARI/GP (*note Pari::, version 2.11.0 or higher,
compiled with GMP as the arithmetic kernel).  Additionally, FLINT (*note
Flint::) can be used if it is available, but it is not mandatory.
Compilation of CM needs a standards compliant C compiler (preferably
GCC).

   These are the steps needed to install CM, provided that the required
libraries are installed in standard locations:

  1. ‘tar xzf cm-0.4.2.tar.gz’

  2. ‘cd cm-0.4.2’

  3. ‘./configure’

  4. ‘make’

     This compiles CM.

  5. ‘make check’

     This performs a few tests to check that CM has been built
     correctly.

     If you get error messages, please report them to the author.

  6. ‘make install’

     This copies the executable applications into the directory
     ‘/usr/local/bin’, the header files into ‘/usr/local/include’, the
     library files into ‘/usr/local/lib’, the data files into
     subdirectories of ‘/usr/local/share/cm’ (see *note Data::) and the
     file ‘cm.info’ into ‘/usr/local/share/info’.

     It is possible to pass the option ‘--prefix=/my/install/directory’
     to the ‘./configure’ step above, so that all files go into
     subdirectories of ‘/my/install/directory’ instead of ‘/usr/local’.

   If auxiliary libraries are to be found in non-standard locations,
these need to be passed in the ‘./configure’ step above by adding
parameters
   • ‘--with-gmp=<gmp_install_dir>’,
   • ‘--with-mpfr=<mpfr_install_dir>’,
   • ‘--with-mpc=<mpc_install_dir>’,
   • ‘--with-mpfrcx=<mpfrcx_install_dir>’
   • ‘--with-pari=<pari_install_dir>’.  and
   • ‘--with-flint=<flint_install_dir>’.

   If you wish to compile the parallel, MPI version ‘ecpp-mpi’ of the
‘ecpp’ binary for elliptic curve primality proofs, you need to pass the
option ‘--enable-mpi’ (and, of course, have an MPI library installed
against which the binary will be compiled and linked).

   For an exhaustive list of configuration parameters, execute
‘./configure --help’.


File: cm.info,  Node: Documentation,  Next: Data,  Prev: Instructions,  Up: Installation

2.2 Documentation
=================

Besides the texinfo documentation obtained by a simple invocation of
‘make’, the commands ‘make dvi’, ‘make ps’, ‘make pdf’ and ‘make html’
create the documentation in the corresponding formats.


File: cm.info,  Node: Data,  Prev: Documentation,  Up: Installation

2.3 Data
========

Some parameterised families of class functions need additional data
(namely, “modular polynomials”), which depend on the parameter value, to
deduce the equation of an elliptic curve from the class polynomial.  A
few modular polynomials are provided and stored in subdirectories of
‘/usr/local/share/cm’ (or of the subdirectory ‘share/cm’ of the
installation directory provided with the ‘--prefix’ configuration
option, respectively).  More precisely, these bivariate polynomials
relate the class function with the modular function j; instantiating in
a class invariant makes it possible to compute the j-invariant of a
corresponding elliptic curve as a root of the modular polynomial.

   An infinite amount of data is needed to handle all possible
discriminants with a given family of class functions, and already
covering all moderately sized discriminants would require gigabytes of
data.  So only a very small sample of modular polynomials is currently
distributed; if you need more, please write to the author.

   More precisely, the subdirectory ‘/usr/local/share/cm/df’ contains
all modular polynomials for double \eta-quotients that are of the
minimally possible degree 2 in j; the subdirectory
‘/usr/local/share/cm/af’ contains all modular polynomials for Atkin
functions of degree 2 in j.  All these are functions of some level N,
invariant under the Fricke-Atkin-Lehner involution, for which the
modular curve X_0^+ (N) is of genus 0.  As a consequence, both roots in
j of the instantiated modular polynomial yield a suitable CM elliptic
curve.  Finally the subdirectory ‘/usr/local/share/cm/mf’ contains all
modular polynomials for triple \eta-quotients of the minimal degree 4 or
of degree 8 in j.


File: cm.info,  Node: Library,  Next: Applications,  Prev: Installation,  Up: Top

3 Library
*********

The code of CM comes first and foremost as a C library making its
functionalities accessible to external applications.  The names of all
publicly accessible, non-static functions and types start by ‘cm_’ to
create a name space proper to CM.

   If you are not interested in programming in library mode, the project
also comes with a few sample applications described in more detail in
*note Applications::; all of them are implemented with just a few
library calls, so describing the library first makes it easier to give
the parameter choices for the applications, and enables you to easily
create small modifications.

   Public constants, types and functions are defined in the file ‘cm.h’;
the exact composition of the types is not important to document here,
since they are usually initialised by calls to dedicated functions and
then passed to further functions needing them.  In general, the usual
trick known from GMP is applied, that is, the types are one-dimensional
arrays of structs, so that the difference between passing arguments by
value or by reference disappears and it is usually not necessary to use
the ‘&’ and ‘*’ operators for referencing and dereferencing.  Also in
GMP style, parameters modified by functions are usually passed first.

* Menu:

* cm_param::
* cm_class::
* cm_curve::
* cm_ecpp::


File: cm.info,  Node: cm_param,  Next: cm_class,  Up: Library

3.1 CM parameters
=================

The ‘cm_param_t’ type holds the main parameters fixed before computing
the class field of an imaginary-quadratic order.  This is first and
foremost the quadratic discriminant D < 0.  For most applications, it
will be enough to consider fundamental discriminants, but this is not a
requirement of the code, so all quadratic discriminants are accepted; if
a non-fundamental discriminant is provided, the corresponding ring class
field is computed.  The second main parameter provides the type of class
function used, either a single function or one out of a parameterised
family; in the latter case also these parameter values are stored.

 -- Type: int_cl_t
     This signed 64 bit integer type is used for discriminants.

 -- Type: cm_param_t
     This type, used for holding the main parameters of a CM setting, is
     defined using the GMP trick of a one-dimensional array of a struct.
     There should be no need to manipulate its fields directly.

 -- Function: bool cm_param_init (cm_param_t PARAM, int_cl_t D, char
          INVARIANT, int MAXDEG, int SUBFIELD, bool VERBOSE)
     This function initialises the PARAM object depending on the main
     input D, a negative quadratic discriminant, and INVARIANT, one of
     the following constants describing a class function or a
     parameterised family of class functions.  Every class function has
     a “height factor” associated to it, which indicates by how much
     (asymptotically for |D| \to \infty) the number of digits of the
     largest coefficient, or equivalently the precision required for the
     floating point approximations, is smaller than for the j-function;
     the latter works for every discriminant, but leads to the largest
     class polynomials.  On the other hand, alternative class functions
     work only for a restricted class of discriminants each.
        • ‘CM_INVARIANT_J’: The modular function j with height factor 1
          by definition.
        • ‘CM_INVARIANT_GAMMA3’: The modular function \sqrt d \,
          \gamma_3, where \gamma_3 is a square root of j - 1728.  The
          additional factor of \sqrt d is needed only to make the class
          polynomial real.  Its height factor is 2, and it works
          whenever D is odd.
        • ‘CM_INVARIANT_GAMMA2’: The modular function \gamma_2, a cube
          root of j.  Its height factor is 3, and it works whenever D is
          not divisible by 3.
        • ‘CM_INVARIANT_WEBER’: One of the Weber functions f, f_1 or f_2
          or its powers.  This is a finite family of class functions.
          One of them works when D is divisible by 4, but not 32, with a
          height factor between 6 and 72.
        • ‘CM_INVARIANT_SIMPLEETA’: Simple \eta-quotients of the form
          \eta (z) / \eta (z/N) for an integer N and their powers (to an
          exponent that divides 24), *note EnMo14::.  The code
          implements only prime power levels N for which X_0(N) is of
          genus 0 (and the simple \eta-quotient is a hauptmodul), so
          that a CM elliptic curve may be deduced without the use of a
          modular polynomial; that is, N \in \{ 3, 5, 7, 13, 4, 9, 25
          \}.  The height factor is between 2 and 24.
        • ‘CM_INVARIANT_DOUBLEETA’: Double \eta-quotients of the form
          (\eta (z/p_1) \eta (z/p_2)) / (\eta (z) \eta (z / (p_1 p_2)))
          for primes p_1 and p_2, and their powers, *note EnSc04:: and
          *note EnSc13::.  The level of the function is essentially N =
          p_1 p_2 (or, to be more precise, a multiple of N and a divisor
          of 24 N, which depends on the congruences satisfied by the p_i
          modulo 24 and the exact power used).  For p_1, p_2 \to \infty,
          these class functions approach a height factor of 12; the
          optimal height factor of 37 is reached for p_1=2, p_2=73.
        • ‘CM_INVARIANT_MULTIETA’: Multiple \eta-quotients for k primes
          p_1, ..., p_k of level N = p_1 \cdots p_k; this is the
          quotient of two products of \eta (z/n), where n varies over
          the 2^k divisors of n, and the n with an odd number of primes
          appear in the numerator, those with an even number of primes
          in the denominator, *note EnSc13::.  The code is implemented
          generically, but currently only triple \eta-quotients (with
          k=3) are actually used.
        • ‘CM_INVARIANT_ATKIN’: Functions for X_0^+(N) of genus 0 for a
          prime level N \in \{ 47, 59, 71, 131 \}; the functions are
          optimal in the sense that they have a pole of lowest degree at
          the cusp for a given family.  The height factor is between 24
          and 36.  On the other hand, this finite family of class
          functions is obtained by applying certain Hecke operators to
          \eta (z) \eta (N z), and the numerical evaluation of these
          Hecke operators is costly.

     For families of class functions, the function selects the
     admissible parameter combination yielding the smallest class
     polynomial.  Admissibility depends mainly on the discriminant (or
     more precisely, on the splitting behaviour of the primes dividing
     the level N in Q (\sqrt D)), but also on the values of the further
     arguments to the function.

     The parameter MAXDEG sets an upper limit on the degree in j of the
     modular polynomial; it has an effect only for infinite families of
     class functions, that is, when INVARIANT is
     ‘CM_INVARIANT_DOUBLEETA’ or ‘CM_INVARIANT_MULTIETA’.  When set to
     0, it is disabled; when set to -1, it is internally set to the
     degree for which modular polynomials are distributed, which makes
     it possible to derive a CM elliptic curve from the class
     polynomial.

     Double and multiple \eta-quotients are known to generate strict
     subfields of the class field in some cases, *note EnSc13::.
     Whether this is admitted depends on the value of SUBFIELD, which
     can take the following constants:
        • ‘CM_SUBFIELD_NEVER’: Do not choose parameters known to
          generate subfields.  This may still happen by chance (and
          break the computation of a Galois tower decomposition).  This
          should be chosen to obtain a generator of the class field.
        • ‘CM_SUBFIELD_PREFERRED’: Whenever possible, compute a subfield
          of the class field, and if several choices are possible,
          prefer the one with the biggest index.  This speeds up the
          computation of elliptic curve primality proofs (ECPP), where
          finding a root of the class polynomial becomes one of the
          bottlenecks for large input.
        • ‘CM_SUBFIELD_OPTIMAL’: Compute the field with the smallest
          class polynomial, regardless of its degree.  This will often
          be a subfield, if available, since the index of the subfield
          lowers the size of the class polynomial by a quadratic factor,
          acting on the degree of the polynomial and on the size of its
          coefficients.  This is intended to yield optimal speed.

     If VERBOSE is set to ‘true’, some information is printed on screen
     during execution.

     If an admissible parameter combination is found, the function
     stores it in ‘param’ and returns ‘true’; otherwise it returns
     ‘false’.

     Since the function does not allocate any memory, there is no
     corresponding function ‘cm_param_clear’.


File: cm.info,  Node: cm_class,  Next: cm_curve,  Prev: cm_param,  Up: Library

3.2 Computing class polynomials
===============================

 -- Type: cm_class_t
     This type is also implemented as a one-dimensional array of a
     struct, but there should not be any need to access its fields.  It
     stores information about the ring class group and, once computed,
     the class polynomial or its decomposition as a tower of Galois
     fields.

   The code for computing class polynomials relies on the PARI library,
which needs to be initialised before calling any of its functions.
While it would be possible to hide this initialisation from the user
(inside ‘cm_class_init’, for instance), this would make it more
difficult to mix CM code with code that uses the PARI library for other
purposes.  So there are special functions for initialising and clearing
the PARI library.

 -- Function: void cm_pari_init ()
     This function must be called before any other function operating on
     class polynomials.  Essentially it encapsulates a call to
     ‘pari_init’.

 -- Function: void cm_pari_clear ()
     This function should be called at the end of working with the CM
     library.  Essentially it encapsulates a call to ‘pari_close’.

 -- Function: void cm_class_init (cm_class_t C, cm_param_t PARAM, bool
          VERBOSE)
     This function should be called after ‘cm_pari_init’.  Given a CM
     parameter PARAM initialised with a call to ‘cm_param_init’, it
     allocates memory and executes some fast precomputations (such as
     the class group), the results of which are stored in C.

     If VERBOSE is set to ‘true’, some information is printed on screen
     during execution.

 -- Function: void cm_class_clear (cm_class_t *C)
     This is the counterpart to ‘cm_class_init’ and should be called
     once the class polynomial is not needed any more to free the
     allocated space.

 -- Function: void cm_class_compute (cm_class_t C, cm_param_t PARAM,
          bool CLASSPOL, bool TOWER, bool VERBOSE)

     Given a previously initialised ‘cm_class_t’ object C and
     corresponding parameter object PARAM, the function computes the
     class polynomial and stores it in C.

     More precisely, if CLASSPOL is set to ‘true’, the function computes
     the class polynomial in one variable X defining the class field; if
     TOWER is set to ‘true’, it computes the same class field as a tower
     of relative extensions of prime degree using the asymptotically
     fast algorithms of *note EnMo03::.  Otherwise said, it computes a
     univariate polynomial f_1 in the variable X_1 defining an absolute
     extension K_1/Q (or K_1/Q (\sqrt D), see below), then a bivariate
     polynomial f_2 in X_1 and X_2 defining a relative extension
     K_2/K_1, and so on.  For the function to have any effect, at least
     one of CLASSPOL or TOWER needs to be set to ‘true’, and usually
     exactly one is enough.

     The class polynomial (or the bivariate polynomials defining a tower
     of Galois extensions) are either real, that is, they have
     coefficients in Z; or they are complex, that is, they have
     coefficients in the ring of integers of the imaginary-quadratic
     field Q (\sqrt D). We write the latter using the standard basis as
     Z + Z \omega, where D_0 is the fundamental discriminant attached to
     D and \omega = \sqrt {D_0} / 2 if D_0 is even and \omega = (1 +
     \sqrt {D_0}) / 2 if D_0 is odd.

     If VERBOSE is set to ‘true’, some information is printed on screen
     during execution.

 -- Function: void cm_class_print_pari (FILE* FILE, cm_class_srcptr C,
          char* FUN, char* VAR)
     Print the computed class polynomial or the relative polynomials
     defining a number field tower from C to FILE (which may be
     ‘stdout’, for instance) in a format that can be copy-pasted or
     loaded into PARI/GP. The arguments FUN and VAR define the function
     and variable names used; if set to ‘NULL’, default values are
     given.

     If computed, the class polynomial is printed with FUN (default ‘f’)
     as the name of the polynomial in the variable VAR (default ‘x’); if
     it is complex, then the second basis element \omega is abbreviated
     to ‘o’.

     If computed, the class polynomial tower is printed with FUN_i as
     the name of the i-th polynomial in VAR.


File: cm.info,  Node: cm_curve,  Next: cm_ecpp,  Prev: cm_class,  Up: Library

3.3 Computing CM elliptic curves
================================

After computing a class field by a call to ‘cm_class_compute’ (either
through a class polynomial as an absolute extension or as a tower of
relative extensions, or both), it can be used to derive a CM elliptic
curve over a finite field.  The CM library implements the computation of
curves over prime fields, and also returns a point of prime order on
such a curve.

 -- Function: void cm_curve_and_point (mpz_t A, mpz_t B, mpz_t X, mpz_t
          Y, cm_param_t PARAM, cm_class_t C, mpz_t P, mpz_t L, mpz_t CO,
          const char* MODPOLDIR, bool PRINT, bool VERBOSE)
     Let C contain a computed class polynomial for the CM parameters
     PARAM.  Let P\geq 5 be a prime such that the elliptic curve with CM
     by the discriminant D in PARAM has L\cdotCO points, where L is
     prime and CO not divisible by L; otherwise said, there are integers
     t and v such that P+1-t=L\cdotCO and 4P=t^2-v^2 D. Then the
     function returns in A and B the parameters of an elliptic curve E :
     Y^2 = X^3 + AX +B over the finite field F_p and in X and Y a point
     P=(X,Y) of order L.

     MODPOLDIR is the name of the base directory containing
     subdirectories with modular polynomials for the different families
     of class functions; for a standard installation, this is
     ‘/usr/local/share/cm’.

     If PRINT is set to true, the computed curve and point coordinates
     are output on screen.

     If VERBOSE is set to ‘true’, some additional information is printed
     on screen during execution.

 -- Function: void cm_curve_crypto_param (mpz_t P, mpz_t N, mpz_t L,
          mpz_t CO, int_cl_t D, int FIELDSIZE, bool VERBOSE)
     This function computes field parameters for a CM curve over a
     finite field for the discriminant D that satisfies the following
     conditions for use in an elliptic curve cryptosystem; notice that
     due to their special nature, CM curves are not recommended for
     cryptography, and that further security considerations should be
     taken into account.  As such, the function is mainly intended to
     test ‘cm_curve_and_point’.  Besides the discriminant it takes
     FIELDSIZE and outputs in P the characteristic of a finite prime
     field with FIELDSIZE bits such that there is an elliptic curve over
     F_p with N=L\cdotCO points such that L is a (pseudo-)prime and
     CO\in \{ 1, 2, 4, 8 \} is the minimal cofactor reachable with this
     discriminant.

     If VERBOSE is set to ‘true’, some information is printed on screen
     during execution.


File: cm.info,  Node: cm_ecpp,  Prev: cm_curve,  Up: Library

3.4 Elliptic Curve Primality Proofs (ECPP)
==========================================

Primality proving with elliptic curves (ECPP) is one of the main
applications of CM elliptic curves over finite fields.  The CM library
implements the asymptotically fast version fastECPP of *note
FrKlMoWi04:: and *note Morain07::.

   Certificates are computed and printed in a format compatible with
PARI/GP.

 -- Function: void cm_ecpp (mpz_t N, const char* MODPOLDIR, const char*
          FILENAME, const char* TMPDIR, bool PRINT, bool TRUST, bool
          CHECK, int PHASES, bool VERBOSE, bool DEBUG)
     Given a prime number N, the function computes an ECPP certificate
     and prints it to screen if PRINT is set to ‘true’.  If FILENAME is
     different from ‘NULL’, the final ECPP certificate is output to the
     file in PARI/GP format, and to a file with additional suffix
     ‘.primo’ in PRIMO format, and the phase 1 and phase 2 partial
     results are read from and written to temporary files with suffices
     ‘.cert1’ and ‘.cert2’, respectively.  The variable PHASES is
     usually set to 0; alternatively, it can be set to 1, in which case
     only the first, downrun phase of ECPP is executed; or it can be set
     to 2, in which case a (potentially partial) first phase result is
     read from a file and only the second, CM phase of ECPP is executed,
     resulting in a (potentially partial, not ending with a number below
     2^{64}) certificate.  Using values different from 0 makes sense
     only when FILENAME is given at the same time.

     If CHECK is set to ‘true’, then the certificate is checked; the
     outcome is printed if VERBOSE is also set to ‘true’.  Notice that
     partial certificates are invalid by definition, even if their
     content is so far correct.

     The directory MODPOLDIR, usually ‘/usr/local/share/cm’, in which
     modular polynomials are stored, is required to be passed to
     ‘cm_curve_and_point’.

     If TRUST is set to ‘true’, then the input number is trusted to be
     pseudoprime; otherwise a quick primality test is run.

     If VERBOSE is set to ‘true’, some information is printed on screen
     during execution.  In particular, if both PRINT and VERBOSE are set
     to ‘false’, the function has no visible effect.

     If additionally to VERBOSE, DEBUG is set to ‘true’, more
     information, in particular on timing of different steps of the ECPP
     algorithm, which is useful only for debugging purposes, is printed
     on screen.

     The parameter TMPDIR, if not ‘NULL’, indicates a directory where
     files can be written and read that are normally recomputed for
     every execution, but that contain data which does not actually
     depend on the number to be certified.  These could theoretically be
     distributed with the code; since they can fill tens of gigabytes,
     this is not practical, however, and they are computed and written
     on the first run.  For the MPI code, this directory needs to be
     accessible from all MPI processes.  If the variable is ‘NULL’, the
     data is recomputed every time.


File: cm.info,  Node: Applications,  Next: References,  Prev: Library,  Up: Top

4 Applications
**************

CM comes with a few applications: ‘classpol’ for computing class
polynomials and ‘cm’ for computing a CM elliptic curve that could be
used for cryptography, and ‘ecpp’ for performing elliptic curve
primality proofs.  The first two compute one class field or CM elliptic
curve and share a certain number of command line arguments; the third
one currently takes no command line arguments.  All of them are
implemented with only a few calls to library functions.  The following
sections present the functionality of each application and the command
line arguments it takes, and also reproduce the essential part of its
code to further illustrate the library interface.

* Menu:

* classpol::
* cm::
* ecpp::


File: cm.info,  Node: classpol,  Next: cm,  Up: Applications

4.1 ‘classpol’
==============

The ‘classpol’ application takes one mandatory argument, ‘-d’ followed
by the absolute value |D| of the discriminant.  It computes and prints
on screen the class polynomial for D obtained using the j-invariant.
The additional parameter ‘-v’ enables more verbose output for the
different steps of the algorithm.
$ classpol -d 207
f = x^6+42653766018394018375*x^5-5002547112103664005187500*x^4
+1819343755841562591564610147379736328125*x^3
-210672109851582446065248197114115955810546875*x^2
+12041028291910181818274355885092809398864746093750*x
-183426864580818496179793649372867188930511474609375

   Class polynomials for alternative class invariants are selected using
the ‘-i’ argument followed by the type of class function; this is the
same as the library constants given in *note CM parameters: cm_param,
with the prefix ‘CM_INVARIANT_’ left out and transformed to lower case;
so ‘CM_INVARIANT_WEBER’ becomes ‘-iweber’, and so on.
$ classpol -d 207 -i doubleeta -v
Discriminant -207, fundamental discriminant -23
Invariant d, parameter 2_73_1_1
Class number 6
...
f = x^6-6*x^5+16*x^4-22*x^3+16*x^2-5*x+1
   The verbose output tells us that -207 is not a fundamental
discriminant, but a multiple of the fundamental discriminant -23, and
that the double \eta-quotient used is of level 2\cdot73 raised to the
power 1 (the second 1 is a technical parameter, indicating the maximal
power that might be needed for this level).

   After evaluating the command line parameters, the essential part of
the code implementing this functionality takes less than ten lines:
cm_pari_init ();
if (!cm_param_init (param, d, invariant, 0, CM_SUBFIELD_NEVER, verbose))
   exit (1);
cm_class_init (c, param, verbose);
cm_class_compute (c, param, true, false, verbose);
cm_class_print_pari (stdout, c, NULL, NULL, NULL);
cm_class_clear (c);
cm_pari_clear ();

   The call to ‘cm_param_init’ initialises the variable PARAM by
checking whether the invariant is suitable for the given discriminants
and choosing a class function if this is the case (such as the
\eta-quotient of level 39 in the example above).  Assuming that the goal
is to compute a class field, parameter combinations known to lead to a
strict subfield are excluded by the constant ‘CM_SUBFIELD_NEVER’.  The 0
indicates that the degree of modular polynomials may be arbitrarily
high, since they would only be needed to derive CM elliptic curves.

   The calls to ‘cm_pari_init’ and ‘cm_class_init’ and their respective
‘clear’ counterparts reserve and free memory and carry out relatively
fast precomputations.  The main activity is launched through the call to
‘cm_class_compute’, in which the boolean values indicate that an
absolute class polynomial is to be computed and not a tower of relative
extensions.  The result is output by a call to ‘cm_class_print_pari’.


File: cm.info,  Node: cm,  Next: ecpp,  Prev: classpol,  Up: Applications

4.2 ‘cm’
========

The ‘cm’ application takes the same command line arguments ‘-d’, ‘-i’
and ‘-v’ as ‘classpol’, *Note classpol::.  It computes a CM curve for
the discriminant D over a prime field of 256 bits such that its
cardinality is “as prime as possible”, that is prime up to possibly a
factor of 2, 4 or 8 depending on D. The ‘-v’ parameter is needed to
print the computed parameters on screen.

cm -d 207 -i doubleeta -v
Invariant d, parameter 2_13_2_2
...
p = 115792089237316195398462578067141184801329650642019283009460547375490535224057
n = 4 * 28948022309329048849615644516785296200162271477044351520651896284230459251901
a = 98163214185470497050837006097264380779085406912553098655936731136039029295843
b = 32285125078980297712817393022671977836076850091512599038419136678099671035526
x = 103397644567197135309633378171745128589056056673675319889645656993433387644320
y = 72297811879224681619558031933509678790723605942283336960075126018884088267112

   The curve has equation E : Y^2 = X^3 + a X + b over the finite prime
field F_p, and its cardinality n is 4 times a prime (for a prime
cardinality, the discriminant must satisfy D \equiv 5 \pmod 8).  The
point of prime order n/4 is given by (x,y).

   Besides the same calls to functions initialising and clearing data,
the core of the implementation is as follows:
if (!cm_param_init (param, d, invariant, -1, CM_SUBFIELD_OPTIMAL, verbose))
   exit (1);
cm_class_compute (c, param, false, true, verbose);
cm_curve_crypto_param (p, n, l, co, d, 256, verbose);
cm_curve_and_point (a, b, x, y, param, c, p, l, co, CM_MODPOLDIR,
   true, verbose);

   Parameter initialisation uses the arguments ‘CM_SUBFIELD_OPTIMAL’ to
indicate that the class invariant expected to be computed in the fastest
time should be used, independently of it leading to a subfield or the
full class field; and -1 to limit the search for class invariants for
which modular polynomials are available.  (The verbose output shows that
the \eta-quotient of level 2\cdot73 is replaced by the quotient of level
2\cdot13 raised to the power 2, which is expected to yield a larger
class polynomial, but for which the modular polynomial is distributed
with the code).

   The boolean arguments to ‘cm_class_compute’ lead to the computation
of the tower decomposition of the class field instead of the full class
polynomial.  The call to ‘cm_curve_crypto_param’ determines a suitable
256 bit prime and curve cardinality N, and the call to
‘cm_curve_and_point’ obtains and prints the curve and the coordinates of
a point of prime order L on the curve.


File: cm.info,  Node: ecpp,  Prev: cm,  Up: Applications

4.3 ‘eccp’
==========

The ‘ecpp’ application computes an ECPP certificate for proving the
primality of the number passed with the ‘-n’ command line argument.  It
is assumed that this number is a suitably tested pseudo-prime; in
particular, if it is smaller than 2^{64} then it is assumed to be prime,
and no certificate is computed.  The number can simply be given in
decimal notation, but also by an arbitrary GP expression.

   The argument ‘-p’ causes printing of the certificate on screen, ‘-v’
enables printing of progress information, and ‘-g’ enables even more
verbose debug output.

$ ecpp -n 'nextprime(10^31)' -p
c = [[10000000000000000000000000000033, -5882759018432034, 12103604, 25,
[3876868516114165308082393519623, 7268598020338906447634857503614]],
[826200196239071096737717, 667597927066, 916, 0,
[376111257001838975439341, 115218092585553575608847]],
[901965279736248361147, 54401389280, 118118316, 0,
[282628664937444390372, 352399418333719760852]]];

   The resulting line defining the certificate can be copy-pasted into a
PARI/GP session and checked using
? primecertisvalid(c)
   with expected result 1.

   Alternatively, the argument ‘-c’ checks the validity of the computed
certificate; to see the result, the option ‘-v’ needs to be enabled.

   The argument ‘-f’ FILENAME stores the computed certificate in a file
of the given name in PARI/GP format, and additionally in the file
FILENAME‘.primo’ in Primo (*note Primo::) format (for checking it with
Primo, one needs to rename the file to FILENAME‘.out’).  Additionally,
it enables checkpointing: During the first phase of ECPP (the downrun
step determining cardinalities of elliptic curves leading to a primality
proof), the file FILENAME‘.cert1’ is written, during the second ECPP
phase of computing the elliptic curves by complex multiplication, the
file FILENAME‘.cert2’ is written.  Upon restart, the program picks up
these files and continues where it has been interrupted.  After a
successful run, these checkpointing files may be deleted.

   Checkpointing is particularly useful with the MPI based parallel
version of the binary, called ‘ecpp-mpi’; this is created and installed
alongside the sequential ‘ecpp’ binary when the ‘--enable-mpi’ configure
option is given.

   Thus in a suitably set up MPI environment,
$ mpirun ecpp-mpi -g -n '10^1000+453' -c -f cert-1000
   computes and checks an ECPP certificate for the first prime with 1001
digits and stores it into the file ‘cert-1000’, while outputting debug
information on screen.

   By default, the code carries out a quick (as opposed to thorough)
primality test, which is meant to catch typos and obvious errors.  If
the number is trusted to be pseudoprime since this has been tested
independently, the command line switch ‘-t’ can be added to drop this
test.

   The environment variable ‘CM_ECPP_TMPDIR’, if set in the shell from
which the binary is invoked, indicates a directory, available from all
MPI processes for the parallel version, in which data that is common
over several invocations can be stored.  The data is then computed on
the first run and read from disk during subsequent runs.  If the
environment variable is not set, the data is recomputed every time.
This concerns files named ‘cm_h.dat’ for class numbers and
‘cm_prim_xxxx.dat’ for primorials.

   Setting this variable also causes checkpoint files named
‘cm_factor_xxxxxxxxxxxxxxxx.dat’ to be written to this directory; they
are useful when certifying very large numbers, for which the program
execution may be interrupted during the second ECPP phase.  They depend
on the number to be certified and can be deleted after the certificate
creation.

   It is possible to run only the first, downrun phase or only the
second, CM phase of ECPP using the command line options ‘-1’ or ‘-2’,
respectively.  Both require that a filename be given with the ‘-f’
option.  Running only the first phase makes it possible to allocate a
different (usually larger) number of MPI processes to this phase.
Running only the second phase is possible also when the first phase has
been completed only partially, so that the first elliptic curves, which
often take a very long time, can be obtained on fewer cores in parallel
with the ongoing first phase.  Notice that in this case a certificate is
written, but that it is considered invalid in particular by the option
‘-c’.  It can be completed by subsequent runs specifying ‘-1’, ‘-2’ or
none of them.


File: cm.info,  Node: References,  Next: Index,  Prev: Applications,  Up: Top

References
**********

   • [Enge09] Andreas Enge.  The complexity of class polynomial
     computation via floating point approximations.  _Mathematics of
     Computation_ 78 (266), 2009, pp.  1089–1107

   • [Enge21] Andreas Enge.  ‘mpfrcx’ – A library for the arithmetic of
     univariate polynomials over arbitrary precision real or complex
     numbers.  INRIA. Version 0.6.3, 2021,
     <http://mpfrcx.multiprecision.org/>

   • [EnGaThZi20] Andreas Enge, Mickaël Gastineau, Philippe Théveny and
     Paul Zimmermann.  ‘mpc’ – A library for multiprecision complex
     arithmetic with exact rounding.  INRIA. Version 1.2.1, 2020,
     <http://mpc.multiprecision.org/>

   • [EnMo03] Andreas Enge and François Morain.  Fast decomposition of
     polynomials with known Galois group.  In Marc Fossorier, Tom
     Høholdt and Alain Poli (eds.): _Applied Algebra, Algebraic
     Algorithms and Error-Correcting Codes – AAECC-15_, 2003, pp.
     254–264

   • [EnMo14] Andreas Enge and François Morain.  Generalised Weber
     functions.  _Acta Arithmetica_ 164 (4), 2014, pp.  309–341

   • [EnSc04] Andreas Enge and Reinhard Schertz.  Constructing elliptic
     curves over finite fields using double eta-quotients.  _Journal de
     Théorie des Nombres de Bordeaux_ 16, 2004, pp.  555–568

   • [EnSc13] Andreas Enge and Reinhard Schertz.  Singular values of
     multiple eta-quotients for ramified primes.  _LMS Journal of
     Computation and Mathematics_ 16, 2013, pp.  407–418

   • [FrKlMoWi04] J. Franke and T. Kleinjung and F. Morain and T. Wirth.
     Proving the Primality of Very Large Numbers with fastECPP. In
     Duncan Buell (ed.): _Algorithmic Number Theory – ANTS-VI_, 2004,
     pp.  194–207

   • [Gretal20] Torbjörn Granlund et al.  ‘gmp’ – GNU multiprecision
     library.  Version 6.2.1, 2020, <http://gmplib.org/>

   • [HaLePeZi20] Guillaume Hanrot, Vincent Lefèvre, Patrick Pélissier,
     Paul Zimmermann et al.  ‘mpfr’ – A library for multiple-precision
     floating-point computations with exact rounding.  Version 4.1.0,
     2020, <http://www.mpfr.org/>

   • [Morain07] FranImplementing the asymptotically fast version of the
     elliptic curve primality proving algorithm.  _Mathematics of
     Computation_ 76 (257), 2007, pp.  493–505

   • [Pari] The PARI group.  ‘PARI/GP’.  Version 2.13.4, 2022,
     <https://pari.math.u-bordeaux.fr/>

   • [Flint] William Hart et al.  ‘FLINT’.  Version 2.9.0, 2022,
     <https://flintlib.org/>

   • [Primo] Marcel Martin.  ‘Primo’.  Version 4.3.3, 2020,
     <http://www.ellipsa.eu/public/primo/primo.html>


File: cm.info,  Node: Index,  Prev: References,  Up: Top

Index
*****

 [index ]
* Menu:

* applications:                          Applications.         (line  6)
* class function:                        Introduction.         (line 18)
* class invariant:                       Introduction.         (line 16)
* class polynomial:                      cm_class.             (line  6)
* classpol:                              classpol.             (line  6)
* cm:                                    cm.                   (line  6)
* CM curve:                              cm_curve.             (line  6)
* cm_class_clear:                        cm_class.             (line 40)
* cm_class_compute:                      cm_class.             (line 45)
* cm_class_init:                         cm_class.             (line 30)
* cm_class_print_pari:                   cm_class.             (line 76)
* cm_class_t:                            cm_class.             (line  6)
* cm_curve_and_point:                    cm_curve.             (line 13)
* cm_curve_crypto_param:                 cm_curve.             (line 36)
* cm_ecpp:                               cm_ecpp.              (line 14)
* cm_param_init:                         cm_param.             (line 24)
* cm_param_t:                            cm_param.             (line 19)
* cm_pari_clear:                         cm_class.             (line 26)
* cm_pari_init:                          cm_class.             (line 21)
* copying conditions:                    Introduction.         (line 24)
* data:                                  Data.                 (line  6)
* documentation:                         Installation.         (line  5)
* documentation <1>:                     Documentation.        (line  6)
* ECPP:                                  cm_ecpp.              (line  6)
* ecpp:                                  ecpp.                 (line  6)
* height factor:                         cm_param.             (line 30)
* installation:                          Installation.         (line  6)
* installation <1>:                      Instructions.         (line  6)
* introduction:                          Introduction.         (line  6)
* int_cl_t:                              cm_param.             (line 16)
* library:                               Library.              (line  6)
* licence:                               Introduction.         (line 24)
* modular polynomial:                    Data.                 (line  6)
* parameters:                            cm_param.             (line  6)
* primality proof:                       cm_ecpp.              (line  6)
* singular value:                        Introduction.         (line 14)
* singular value <1>:                    Introduction.         (line 16)



Tag Table:
Node: Top954
Node: Introduction1185
Node: Installation2825
Node: Instructions2995
Node: Documentation5487
Node: Data5832
Node: Library7663
Node: cm_param9107
Node: cm_class16766
Node: cm_curve21210
Node: cm_ecpp23907
Node: Applications27151
Node: classpol27983
Node: cm30960
Node: ecpp33665
Node: References38296
Ref: Enge0938407
Ref: Enge2138594
Ref: EnGaThZi2038828
Ref: EnMo0339083
Ref: EnMo1439372
Ref: EnSc0439509
Ref: EnSc1339720
Ref: FrKlMoWi0439917
Ref: Gretal2040152
Ref: HaLePeZi2040288
Ref: Morain0740546
Ref: Pari40736
Ref: Flint40846
Ref: Primo40947
Node: Index41060

End Tag Table


Local Variables:
coding: utf-8
End:
